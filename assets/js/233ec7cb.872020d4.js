"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[312],{3833:e=>{e.exports=JSON.parse('{"functions":[{"name":"new","desc":"Creates a new Sequence object\\n\\n```lua\\nlocal MySequence.new({ Autotick = true, ClearOnTick = true, Limit = 10 }, function(sequenceTable)\\n    for _, object in sequenceTable do\\n        print(\\"Object \\" .. object .. \\" is in the sequence!\\")\\n    end\\nend)\\n```","params":[{"name":"settings","desc":"","lua_type":"{}"},{"name":"callback","desc":"","lua_type":"function"}],"returns":[{"desc":"","lua_type":"Sequence<T>\\r\\n"}],"function_type":"static","tags":["Sequence"],"source":{"line":103,"path":"src/init.lua"}},{"name":"Includes","desc":"Adds an object to the Sequence to be run on Sequence:ForceTick()\\n\\n\\n```lua\\nlocal MySequence.new({ Autotick = true }, function(sequenceTable) end)\\n\\nlocal currentSequence = MySequence:Includes(\\"Hey there!\\")\\nprint(newSequence)\\n\\n<Output>\\n{ \\"Hey there!\\" }\\n```","params":[{"name":"object","desc":"","lua_type":"T"},{"name":"index","desc":"Places at end if nil","lua_type":"number"}],"returns":[{"desc":"","lua_type":"SequenceTable<T>\\r\\n"}],"function_type":"method","source":{"line":143,"path":"src/init.lua"}},{"name":"Excludes","desc":"Removes an object from the Sequence at given index\\n\\n\\n```lua\\nlocal MySequence.new({ Autotick = true }, function(sequenceTable) end)\\n\\nMySequence:Includes(\\"Hey there!\\")\\nlocal removedObject = MySequence:Excludes(1)\\nprint(removedObject)\\n\\n<Output>\\nHey there!\\n```","params":[{"name":"index","desc":"","lua_type":"number"}],"returns":[{"desc":"","lua_type":"T\\r\\n"}],"function_type":"method","source":{"line":180,"path":"src/init.lua"}},{"name":"ExcludeFromObject","desc":"Removes an object from the Sequence at given index\\n\\n\\n```lua\\nlocal MySequence.new({ Autotick = true }, function(sequenceTable) end)\\n\\nMySequence:Includes(\\"Hey there!\\")\\nprint(MySequence:GetCurrentSequence())\\n\\nMySequence:ExcludeFromObject(\\"Hey there!\\")\\nprint(MySequence:GetCurrentSequence())\\n\\n<Output>\\n{ \\"Hey there!\\" }\\n{}\\n```","params":[{"name":"object","desc":"","lua_type":"T"}],"returns":[{"desc":"","lua_type":"void\\r\\n"}],"function_type":"method","source":{"line":215,"path":"src/init.lua"}},{"name":"Get","desc":"Used to find the object at index\\n\\n\\n```lua\\nlocal MySequence.new({ Autotick = true }, function(sequenceTable) end)\\n\\nMySequence:Includes(\\"Hey there!\\")\\n\\nlocal foundObject = MySequence:Get(1)\\nprint(foundObject)\\n\\n<Output>\\nHey there!\\n```","params":[{"name":"index","desc":"","lua_type":"number"}],"returns":[{"desc":"","lua_type":"T\\r\\n"}],"function_type":"method","source":{"line":249,"path":"src/init.lua"}},{"name":"Set","desc":"Adds object to sequence, but replaces any current value at given index\\n\\n\\n```lua\\nlocal MySequence.new({ Autotick = true }, function(sequenceTable)\\n    print(sequenceTable)\\nend)\\n\\nMySequence:Includes(\\"Hey there!\\")\\n\\nlocal currentSequence = MySequence:Set(\\"Nice to meet you!\\", 1)\\n\\n<Output>\\n{ \\"Nice to meet you!\\" }\\n```","params":[{"name":"object","desc":"","lua_type":"T"},{"name":"index","desc":"Sets object at index 1 if nil","lua_type":"number"}],"returns":[{"desc":"","lua_type":"SequenceTable<T>\\r\\n"}],"function_type":"method","source":{"line":283,"path":"src/init.lua"}},{"name":"GetCurrentSequence","desc":"Returns current status of the `SequenceTable<T>`\\n\\n```lua\\nlocal MySequence.new({ Autotick = false }, function(sequenceTable) end)\\n\\nMySequence:Set(\\"Hey there!\\")\\n\\nlocal currentSequence = MySequence:GetCurrentSequence()\\nprint(currentSequence)\\n\\n<Output>\\n{ \\"Hey there!\\" }\\n```","params":[],"returns":[{"desc":"","lua_type":"SequenceTable<T>\\r\\n"}],"function_type":"method","source":{"line":317,"path":"src/init.lua"}},{"name":"SetCurrentLimit","desc":"Changes the limit of objects that the `SequenceTable<T>` can hold\\n\\n\\n```lua\\nlocal MySequence.new({ Autotick = true, Limit = 1 }, function(sequenceTable)\\n    print(sequenceTable)\\nend)\\n\\nMySequence:Includes(\\"Hey there!\\")\\nMySequence:Includes(\\"Nice to meet you!\\", 1)\\n\\nMySequence:SetCurrentLimit(3)\\n\\nMySequence:Includes(\\"I\'ve been good!\\", 1)\\nMySequence:Includes(\\"What about you?\\")\\nMySequence:Includes(\\"Nothing much!\\", 2)\\n\\n<Output>\\n{ \\"I\'ve been good!\\", \\"Nothing much!\\", \\"Nice to meet you!\\" }\\n\\n-- Remember that :Includes() always places the object at the end.\\n-- But inputting a number pushes all that are ahead of it, up!\\n```","params":[{"name":"amount","desc":"","lua_type":"number"}],"returns":[{"desc":"","lua_type":"void\\r\\n"}],"function_type":"method","source":{"line":348,"path":"src/init.lua"}},{"name":"Iterate","desc":"Runs a `tick cycle` over objects from first till `stopAt`\\n\\n\\n```lua\\nlocal MySequence.new({ Autotick = false }, function(sequenceTable)\\n    print(sequenceTable)\\nend)\\n\\nMySequence:Includes(\\"Hey there!\\")\\nMySequence:Includes(\\"Nice to meet you!\\")\\nMySequence:Includes(\\"I\'ve been good!\\")\\nMySequence:Includes(\\"What about you?\\")\\nMySequence:Includes(\\"Nothing much!\\")\\n\\nMySequence:Iterate(4)\\n\\n<Output>\\n{ \\"Hey there!\\", \\"Nice to meet you!\\", \\"I\'ve been good!\\", \\"What about you?\\" }\\n```","params":[{"name":"stopAt","desc":"","lua_type":"number"}],"returns":[{"desc":"","lua_type":"void\\r\\n"}],"function_type":"method","source":{"line":375,"path":"src/init.lua"}},{"name":"ForceTick","desc":"Forcefully runs a `tick cycle` through every sequence object\\n\\n```lua\\nlocal MySequence.new({ Autotick = false }, function(sequenceTable)\\n    print(sequenceTable)\\nend)\\n\\nMySequence:Includes(\\"Hey there!\\")\\nMySequence:Includes(\\"Nice to meet you!\\")\\n\\ntask.wait(10)\\n\\nMySequence:Includes(\\"I\'ve been good!\\")\\n\\nMySequence:ForceTick()\\n\\n<Output>\\n-- After ~10 seconds\\n{ \\"Hey there!\\", \\"Nice to meet you!\\", \\"I\'ve been good!\\" }\\n```","params":[],"returns":[{"desc":"","lua_type":"void\\r\\n"}],"function_type":"method","source":{"line":427,"path":"src/init.lua"}},{"name":"Clean","desc":"Cleans up Sequence object and empties the `SequenceTable<T>`\\n\\n```lua\\nlocal MySequence = Sequence.new({ Autotick = false }, function(sequenceTable) end)\\n\\nMySequence:Includes(\\"Hey there!\\")\\nprint(MySequence:GetCurrentSequence())\\n\\nMySequence:Clean()\\n\\nprint(MySequence:GetCurrentSequence())\\n\\n<Output>\\n{ \\"Hey there!\\" }\\n{}\\n```","params":[],"returns":[{"desc":"","lua_type":"boolean\\r\\n"}],"function_type":"method","source":{"line":487,"path":"src/init.lua"}},{"name":"Destroy","desc":"Destroys `Sequence` object permanently to never be restored","params":[],"returns":[{"desc":"","lua_type":"void\\r\\n"}],"function_type":"method","source":{"line":497,"path":"src/init.lua"}}],"properties":[{"name":"Autotick","desc":"When enabled, it will automatically run a `tick cycle` on next resumption cycle","lua_type":"boolean","tags":["true by default"],"source":{"line":71,"path":"src/init.lua"}},{"name":"ClearOnTick","desc":"When enabled, `SequenceTable<T>` is cleared after the `tick cycle` has completed","lua_type":"boolean","tags":["true by default"],"source":{"line":77,"path":"src/init.lua"}},{"name":"Limit","desc":"When set to a number, SequenceTable<T> won\'t allow any more objects than limit amount. If you `:Include()` an object that pushes `SequenceTable<T>` over the limit, it will remove any objects over said limit","lua_type":"number","tags":["nil by default"],"source":{"line":83,"path":"src/init.lua"}}],"types":[{"name":"void","desc":"Commonly used term for a function that has no return value","lua_type":"nil","source":{"line":27,"path":"src/init.lua"}},{"name":"SequenceTable<T>","desc":"Used to hold all given objects","lua_type":"{ T }","source":{"line":33,"path":"src/init.lua"}},{"name":"Sequence<T>","desc":"Object in which you run the `Sequence` code with","lua_type":"metatable","source":{"line":39,"path":"src/init.lua"}}],"name":"Sequence","desc":"Sequence allows you to sort tasks in sequential order to run. These tasks are run either on the next resumption cycle, or on-command!\\n\\nPotential uses for this module would be a turn-base game to determine when a player will go, setting up a network package handler, or even just for sending out notifications to players!","source":{"line":20,"path":"src/init.lua"}}')}}]);